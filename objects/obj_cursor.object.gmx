<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//ORIGINAL START
/*if(object_is_ancestor(object_index,parent_npc))
{
    if(moving)
    {
        // Update isometric coordinates and depth while moving.
        isox = iso_get_x(x,y);
        isoy = iso_get_y(x,y);
        depth = -isoy-8;
        part_system_depth(PS_1,-isoy-8);
        // If moving, stop when snapped.
        if(x+16 == tile.x and y+16 == tile.y) { endMoving(); }
    }
}*/
//ORIGINAL END

// Isometric coordinates, depth, movement end, that kind of stuff...
// Do not modify.
if(object_is_ancestor(object_index,parent_npc))
{
    /*if(moving == -1)
    {
        isox = iso_get_x(x,y);
        isoy = iso_get_y(x,y);
        depth = -isoy-8;
        part_system_depth(PS_1,-isoy-8);
        moving = 0;
    }
    else */if(moving)
    {
        if(path_position == 1) endMoving();
        isox = iso_get_x(x,y);
        isoy = iso_get_y(x,y);
        depth = -isoy-8;
        part_system_depth(PS_1,-isoy-8);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Cursor.
if(object_index == obj_cursor)
{
    // Snap to normal grid.
    x = iso_get_regx(mouse_x,mouse_y)+16;
    y = iso_get_regy(mouse_x,mouse_y)-48;
    if(!place_snapped(32,32)) move_snap(32,32);

    // The location of the cursor on the normal grid.
    obj_cursorLocation.x = x;
    obj_cursorLocation.y = y;

    // The cursor's isometric position.
    depth = -iso_get_y(x,y)-7;
    obj_cursorLocation.depth = -iso_get_y(x,y)-9;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// How a character reacts to the mouse and moves. Modify at your own risk.
if(object_is_ancestor(object_index,parent_npc))
{
    if(actingInstance)
    {
        if(mouse_check_button(mb_left)) mouse_left();
    }
    else
    {
        //NPC Movement
    }
    if(drawPath)
    {
        if(!moving) initMoving();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Set view.
//view_xview[0] = floor(obj_fire1.isox-320);
//view_yview[0] = floor(obj_fire1.isoy-240);
//instance_create(room_width/2,room_height/2,obj_view);
// view object spawned in centre of room

// Draw background.
if(object_index == obj_background)
{
    if(drawRegular) draw_sprite(sprite_index,image_index,x+304,y+32);
    draw_sprite(spr_iso_background,image_index,isox,isoy);
}

// Character.
else if(object_is_ancestor(object_index,parent_npc))
{
    // Draw path.
    if(drawPath)
    {
        var isoXX1,isoYY1,isoXX2,isoYY2;
        for(i = 0; i &lt; Dest; i += 1)
        {
            if(current &lt; i)
            {
                isoXX1 = iso_get_x(path_get_point_x(pathCheck,i-1),path_get_point_y(pathCheck,i-1));
                isoYY1 = iso_get_y(path_get_point_x(pathCheck,i-1),path_get_point_y(pathCheck,i-1))+24;
                isoXX2 = iso_get_x(path_get_point_x(pathCheck,i),path_get_point_y(pathCheck,i));
                isoYY2 = iso_get_y(path_get_point_x(pathCheck,i),path_get_point_y(pathCheck,i))+24;
                part_emitter_region(global.PS_0,global.EM_0,isoXX1,isoXX2,isoYY1,isoYY2,ps_shape_line,ps_distr_linear);
                part_emitter_burst(global.PS_0,global.EM_0,global.pathEffect,point_distance(isoXX1,isoYY1,isoXX2,isoYY2)/4);
            }
        }
    }
    // Draw effects.
    if(effectType == 1)
    {
        part_emitter_region(PS_1,EM_1,
        isox+sprite_get_bbox_left(sprite_index),
        isox+sprite_get_bbox_right(sprite_index),
        isoy+sprite_get_bbox_top(sprite_index)-12,
        isoy+sprite_get_bbox_bottom(sprite_index)-12,
        ps_shape_ellipse,ps_distr_invgaussian);
        part_emitter_burst(PS_1,EM_1,global.bodyFlame,10);
    }
    
    // Draw character.
    setSprite();
    if(drawRegular)
    {
        if(actingInstance) draw_sprite(spr_actingInstance,0,x+304,y+32);
        else draw_sprite(spr_actingInstance,1,x+304,y+32);
        draw_sprite(spr_occupiedTile,0,tile.x+304,tile.y+32);
    }
    draw_sprite(sprite_index,image_index,isox,isoy-12);
}

// Wall.
else if(object_index == obj_wall)
{
    // Draw wall.
    if(drawRegular) draw_sprite(sprite_index,image_index,x+304,y+32);
    draw_sprite(spr_isometric,image_index,isox,isoy);
}

// Draw the cursor.
else if(!collision_point(obj_cursorLocation.x,obj_cursorLocation.y,obj_background,false,true)) exit;
if(object_index == obj_cursor)
{
    draw_sprite(spr_iso_cursor,0,iso_get_x(x,y),iso_get_y(x,y));
}
else if(object_index == obj_cursorLocation)
{
    draw_sprite(spr_iso_cursor,1,iso_get_x(x,y),iso_get_y(x,y));
    if(drawRegular) draw_sprite(spr_cursorLocation,image_index,x+304,y+32);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
